#!/usr/bin/env bash
set -eo pipefail # Exit on error, treat unset variables as an error, and propagate pipeline failures

# db-backupper - PostgreSQL Docker Backup & Restore Tool for S3
# Main executable that orchestrates the backup and restore operations

# Set up the environment and load modules
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source utility functions first (includes path setup)
echo "DEBUG: About to source utils.sh"
source "${SCRIPT_DIR}/lib/utils.sh"
echo "DEBUG: Successfully sourced utils.sh"

# Set up robust PATH for cron environments
echo "DEBUG: About to call setup_path"
setup_path
echo "DEBUG: Successfully called setup_path"

# Determine the configuration directory
echo "DEBUG: About to call get_script_dir"
CONFIG_DIR="$(get_script_dir)"
echo "DEBUG: CONFIG_DIR set to: $CONFIG_DIR"

# Source all modules
echo "DEBUG: About to source config.sh"
source "${SCRIPT_DIR}/lib/config.sh"
echo "DEBUG: Successfully sourced config.sh"

echo "DEBUG: About to source database.sh"
source "${SCRIPT_DIR}/lib/database.sh"
echo "DEBUG: Successfully sourced database.sh"

echo "DEBUG: About to source backup.sh"
source "${SCRIPT_DIR}/lib/backup.sh"
echo "DEBUG: Successfully sourced backup.sh"

echo "DEBUG: About to source restore.sh"
source "${SCRIPT_DIR}/lib/restore.sh"
echo "DEBUG: Successfully sourced restore.sh"

# Load configuration
load_config

# Usage information
usage() {
    echo "Usage: db-backupper <action> [options]"
    echo ""
    echo "Actions:"
    echo "  backup [--prefix <string>]  Dump PostgreSQL DB, compress, and upload to S3."
    echo "                              --prefix: Optional path prefix for S3 storage location."
    echo "                                        e.g., 'folder1/folder2/' results in storing at 'S3_BACKUP_PATH/folder1/folder2/dbname_timestamp.tar.gz'"
    echo "  download <s3_url> [dir]     Download archive from S3 and extract to current directory or specified directory."
    echo "                              <s3_url> is the full S3 path, e.g., s3://${S3_BUCKET_NAME}/${S3_BACKUP_PATH}dbname_timestamp.tar.gz"
    echo "                              [dir] is an optional output directory (defaults to current directory)"
    echo "  restore <dump_path> [--purge|--no-purge]"
    echo "                              Restore from a SQL dump file. Optional flags to control database purging:"
    echo "                              --purge: Drop and recreate the database before restoring"
    echo "                              --no-purge: Preserve existing database (default, will ask if neither specified)"
    echo "  restore-legacy <s3_url>     (DEPRECATED) Download archive from S3, decompress, and restore to PostgreSQL DB in one step."
    echo "                              <s3_url> is the full S3 path, e.g., s3://${S3_BUCKET_NAME}/${S3_BACKUP_PATH}dbname_timestamp.tar.gz"
    echo "  help                        Show this help message."
    echo ""
    echo "Configuration is read from: ${CONFIG_DIR}/backup.conf"
    echo ""
    echo "Example workflow:"
    echo "  1. db-backupper download s3://${S3_BUCKET_NAME}/${S3_BACKUP_PATH}dbname_timestamp.tar.gz"
    echo "  2. db-backupper restore ./dump_dbname_timestamp.sql --purge"
}

# Main function
main() {
    # Check for required commands globally
    check_all_commands

    if [[ $# -eq 0 ]]; then
        usage
        exit 1
    fi

    local action="$1"
    shift # Consume the action

    case "$action" in
        backup)
            local backup_filename_prefix_arg=""
            # Parse options for backup
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --prefix)
                        if [[ -z "$2" ]]; then # Check if $2 is empty or not provided
                            log_error "ERROR: --prefix requires an argument."
                            usage
                            exit 1
                        fi
                        backup_filename_prefix_arg="$2"
                        shift 2 # Consume --prefix and its value
                        ;;
                    *)
                        log_error "ERROR: Unknown option or argument for backup: $1"
                        usage
                        exit 1
                        ;;
                esac
            done
            action_backup "$backup_filename_prefix_arg"
            ;;
        download)
            if [[ $# -eq 0 ]]; then
                log_error "ERROR: S3 URL must be provided for download."
                usage
                exit 1
            fi
            local s3_url_for_download="$1"
            local output_dir="${2:-$(pwd)}"
            # Validate S3 URL format
            if [[ ! "$s3_url_for_download" =~ ^s3:// ]]; then
                log_error "Invalid S3 URL format for download. Expected: s3://bucket-name/path/to/archive.tar.gz"
                exit 1
            fi
            action_download "$s3_url_for_download" "$output_dir"
            ;;
        restore)
            if [[ $# -eq 0 ]]; then
                log_error "ERROR: SQL dump file path must be provided for restore."
                usage
                exit 1
            fi
            local dump_path="$1"
            local purge_option="${2:-}"
            action_restore "$dump_path" "$purge_option"
            ;;
        restore-legacy)
            if [[ $# -eq 0 ]]; then
                log_error "ERROR: S3 URL must be provided for restore-legacy."
                usage
                exit 1
            fi
            if [[ $# -gt 1 ]]; then
                log_error "ERROR: Too many arguments for restore-legacy. Expected S3 URL only. Got: $*"
                usage
                exit 1
            fi
            local s3_url_for_restore="$1"
             # Validate S3 URL format
            if [[ ! "$s3_url_for_restore" =~ ^s3:// ]]; then
                log_error "Invalid S3 URL format for restore. Expected: s3://bucket-name/path/to/archive.tar.gz"
                exit 1
            fi
            action_restore_legacy "$s3_url_for_restore"
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            # If action itself is -h or --help, it wasn't caught above, handle here
            if [[ "$action" == "-h" || "$action" == "--help" ]]; then
                 usage
                 exit 0
            fi
            log_error "Invalid action: '$action'"
            usage
            exit 1
            ;;
    esac
}

# Script entry point
main "$@"